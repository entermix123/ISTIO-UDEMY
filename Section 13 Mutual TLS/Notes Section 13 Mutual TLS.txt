Section 13 Mutual TLS
=====================

Section content:
----------------
50. Why is encryption needed inside a cluster?
51. How Istio can upgrade traffic to TLS
52. Enabling mTLS - it's Automatic
53. STRICT vs PERMISSIVE mTLS
54. STRICT mTLS Works in Both Directions



PREREQUISITES
-------------

Optional
--------
Set alias for kubectl in bash 
	1. Add the alias: bash --> echo "alias k='kubectl'" >> ~/.bashrc
	2. Apply it: bash --> source ~/.bashrc


INSTALL THE SETUP WITH THE PROVIDED MANIFESTS
---------------------------------------------------------------------------------------
We will use resources in folder 'Manifests'
	- 1-istio-init.yaml
	- 2-istio-minikube.yaml
	- 3-kiali-secret.yaml
	- 4-label-default-namespace.yaml
	- 5-application-no-istio.yaml
	- 6-istio-rules.yaml

Navigate to the resource folder and setup the scenario:
	Delete the old Minikube cluster
		terminal --> minikube delete

	Create new Minikube cluster
		terminal --> minikube start --cpus 4 --memory 8192 --driver docker

	Point Kubectl to Minikube cluster
		terminal --> kubectl config use-context minikube

	Test the connection
		terminal --> kubectl get nodes

		# result:
		NAME       STATUS   ROLES           AGE   VERSION
		minikube   Ready    control-plane   10s   v1.35.0


	Deply provided resources
		terminal --> cd 1-Telemetry
		
ISNTALL LATEST ISTIO - for Widnows
--------------------
Download latest istio
	bash --> curl -L https://github.com/istio/istio/releases/download/1.23.0/istio-1.23.0-win.zip -o istio.zip

	bash --> unzip istio.zip
	bash --> cd istio-1.23.0
	
Add to PATH
	bash --> export PATH=$PWD/bin:$PATH

Install Istio
	bash --> istioctl install --set profile=demo -y

Enable sidecar injection on the working namespace (default)
	bash --> kubectl label namespace default istio-injection=enabled

Verify installation
	bash --> kubectl get pods -n istio-system

	# result:
	NAME                                    READY   STATUS    RESTARTS   AGE
	istio-egressgateway-9cc489bfc-kj4pd     1/1     Running   0          76s
	istio-ingressgateway-6f868bc4f7-qkmc6   1/1     Running   0          76s
	istiod-77cb77f5b8-7clw4                 1/1     Running   0          95s

	# all pods must be running

APPLY PROVIDED RESOURCES
------------------------
Apply the provided init file - this will modify the installed Istio installation to work with the provided resources
	bash -->  kubectl apply -f 1-istio-init.yaml

Apply the CRD 2-istio-minikube.yaml
	bash --> kubectl apply -f 2-istio-minikube.yaml

Test installation
	bash --> kubectl get pods -n istio-system

	# result:
	NAME                                   READY   STATUS    RESTARTS   AGE
	grafana-595d876fb8-f7kdf               1/1     Running   0          5m46s	# grafana runs with prometheus
	istio-egressgateway-5898456ddf-jmqgv   1/1     Running   0          5m47s	# egress gateway (outgoing traffic)
	istio-ingressgateway-7d95dbfcc-b89w4   1/1     Running   0          5m47s	# ingress gateway (incoming traffic)
	istiod-65cdd474f7-l4wmp                1/1     Running   0          5m47s	# istio deamon
	jaeger-76d7cfcfdb-b2xx9                1/1     Running   0          5m46s	# Jaeger Traces service
	kiali-594fb85dc8-s68bb                 1/1     Running   0          5m45s	# Kiali UI service
	prometheus-65bdbcd97f-ntvnw            2/2     Running   0          5m46s	# prometheus works with grafana


Apply the CRD 3-kiali-secret.yaml to prevent login requirements to Kiali UI every time
	bash --> kubectl apply -f 3-kiali-secret.yaml

	# result: secret/kiali created

Apply the CRD 4-label-default-namespace.yaml to label default namespace to be Istio enabled. 
	bash --> kubectl apply -f 4-label-default-namespace.yaml
	
	# result: namespace/default configured

	Confirm labeling
		bash --> kubectl describe ns default

		# result: Labels:       istio-injection=enabled

	# This will add the additional proxy container is every pod application in the 'default' namespace.
	# It is important to apply this label to the working namespace before start deploying the application

Deploy the application
	bash --> kubectl apply -f 5-application-no-istio.yaml


Create/expose Kiali service
	terminal --> kubectl expose deployment kiali -n istio-system --type=NodePort --port=20001 --target-port=20001

	# result: service/kiali exposed


Check Kiali service existance
	terminal --> kubectl get svc -n istio-system

	# result:
	NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                                      
	kiali                  NodePort    10.100.117.213   <none>        20001:30306/TCP  # Created Kiali UI service                                                        


Expose Istio Kiali UI
	terminal --> kubectl port-forward svc/kiali 20001:20001 -n istio-system
		
	Access the KIali UI on http://localhost:20001                                                    

Expose Jaeger (tracing) service
	terminal --> kubectl port-forward svc/tracing 8080:80 -n istio-system
		
	We can now access Jaeger on http://localhost:8080

Apply the istion confguration
	terminal --> k apply -f 6-gateway.yaml

Expose the application with port forward
	terminal --> kubectl port-forward svc/istio-ingressgateway -n istio-system 31380:80

	Access the application on http://localhost:31380/
---------------------------------------------------------------------------------------





50. Why is encryption needed inside a cluster?
==============================================

This feature secure the communication between pods with TLS (HTTPS). It assures communication between different Clusters and Nodes in different regions and availability zones if we deploy on cloud infrastructure.


51. How Istio can upgrade traffic to TLS
========================================

Encryption is handled by Istio Proxies (envoy/sidecar). It means that proxies identities are confirmed by certificates. Ceritiface handlin is part of istiod daemon. 

Mutual TLS is presented on picture mutualTLS.png.

Whai Istio can do?
1. Enforce a policy that BLOCKS all non TLS traffic between prxies
2. Automatically upgrade all proxy-proxy communication to use mTLS (recommended)


52. Enabling mTLS - it's Automatic
==================================

Enabled by default !!!

In Kiali UI / Graph / Display / check 'Security'

We can see a padlock icon that appears on the communication lines. This means that security is mutual TLS enabled.


53. STRICT vs PERMISSIVE mTLS
=============================

Permissive TLS is working both directions - from proxy to whatever. If communication comes from non proxy source the communication is NOT secure but it will pass!

The case is presented in picture permissivemTLS.png.

If we use STRICT mTLS the communication is secure both ways. If there is non proxy and can't be upgraded the communication will be rejected!

Istio Documentation - https://istio.io/latest/docs/reference/config/security/peer_authentication/#PeerAuthentication-MutualTLS

We can use file enforce-mtls-only.yaml.

enforce-mtls-only.yaml
-------------------------------------------------
# This will enforce that ONLY traffic that is TLS is allowed between proxies
apiVersion: "security.istio.io/v1beta1"
kind: "PeerAuthentication"
metadata:
  name: "default"
  namespace: "istio-system"         # destination namespace
spec:
  mtls:
    mode: STRICT                    # mutualTLS mode
-------------------------------------------------

Apply the policy
	terminal --> k apply -f enforce-mtls-only.yaml

	# result: peerauthentication.security.istio.io/default created


This will cause all non proxy communications to fail and we amy need to implement proies in all namespaces and containers.

If we still want to have some http communications (from non Istio namespace) that are not proxy enabled we can use PERMISSIVE mode.

We have applied mutual TLS enabled by default but it is on PERMISSIVE mode!



54. STRICT mTLS Works in Both Directions
========================================











